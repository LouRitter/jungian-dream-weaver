-- STEP-BY-STEP MIGRATION SCRIPT
-- Run these one at a time in your Supabase SQL Editor

-- STEP 1: Add the identified_themes column to dreams table
ALTER TABLE public.dreams ADD COLUMN IF NOT EXISTS identified_themes TEXT[];

-- STEP 2: Set default themes for all existing dreams
UPDATE public.dreams 
SET identified_themes = ARRAY['Transformation', 'Self-Discovery', 'Integration']
WHERE identified_themes IS NULL;

-- STEP 3: Create tags table
CREATE TABLE IF NOT EXISTS public.tags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  name TEXT NOT NULL UNIQUE,
  type TEXT NOT NULL
);

-- STEP 4: Create dream_tags join table
CREATE TABLE IF NOT EXISTS public.dream_tags (
  dream_id BIGINT NOT NULL REFERENCES public.dreams(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES public.tags(id) ON DELETE CASCADE,
  PRIMARY KEY (dream_id, tag_id)
);

-- STEP 5: Enable RLS on tags table
ALTER TABLE public.tags ENABLE ROW LEVEL SECURITY;

-- STEP 6: Create read policy for tags
CREATE POLICY "Public tags are viewable by everyone." ON public.tags FOR SELECT USING ( true );

-- STEP 7: Enable RLS on dream_tags table
ALTER TABLE public.dream_tags ENABLE ROW LEVEL SECURITY;

-- STEP 8: Create read policy for dream_tags
CREATE POLICY "Public dream_tags are viewable by everyone." ON public.dream_tags FOR SELECT USING ( true );

-- STEP 9: Insert tags for symbols (run this after steps 1-8)
INSERT INTO public.tags (name, type)
SELECT DISTINCT 
  jsonb_array_elements(identified_symbols)->>'symbol' as symbol_name,
  'symbol' as type
FROM public.dreams 
WHERE identified_symbols IS NOT NULL
ON CONFLICT (name) DO NOTHING;

-- STEP 10: Insert tags for archetypes
INSERT INTO public.tags (name, type)
SELECT DISTINCT 
  jsonb_array_elements(identified_archetypes)->>'archetype' as archetype_name,
  'archetype' as type
FROM public.dreams 
WHERE identified_archetypes IS NOT NULL
ON CONFLICT (name) DO NOTHING;

-- STEP 11: Insert tags for themes
INSERT INTO public.tags (name, type)
SELECT DISTINCT 
  unnest(identified_themes) as theme_name,
  'theme' as type
FROM public.dreams 
WHERE identified_themes IS NOT NULL
ON CONFLICT (name) DO NOTHING;

-- STEP 12: Link dreams to symbol tags
INSERT INTO public.dream_tags (dream_id, tag_id)
SELECT DISTINCT
  d.id as dream_id,
  t.id as tag_id
FROM public.dreams d,
     jsonb_array_elements(d.identified_symbols) as symbol_data,
     public.tags t
WHERE t.name = symbol_data->>'symbol' 
  AND t.type = 'symbol'
ON CONFLICT (dream_id, tag_id) DO NOTHING;

-- STEP 13: Link dreams to archetype tags
INSERT INTO public.dream_tags (dream_id, tag_id)
SELECT DISTINCT
  d.id as dream_id,
  t.id as tag_id
FROM public.dreams d,
     jsonb_array_elements(d.identified_archetypes) as archetype_data,
     public.tags t
WHERE t.name = archetype_data->>'archetype' 
  AND t.type = 'archetype'
ON CONFLICT (dream_id, tag_id) DO NOTHING;

-- STEP 14: Link dreams to theme tags
INSERT INTO public.dream_tags (dream_id, tag_id)
SELECT DISTINCT
  d.id as dream_id,
  t.id as tag_id
FROM public.dreams d,
     unnest(d.identified_themes) as theme_name,
     public.tags t
WHERE t.name = theme_name 
  AND t.type = 'theme'
ON CONFLICT (dream_id, tag_id) DO NOTHING;

-- STEP 15: Verify the migration (optional - run this to check results)
SELECT 
  'Dreams with themes' as category,
  COUNT(*) as count
FROM public.dreams 
WHERE identified_themes IS NOT NULL

UNION ALL

SELECT 
  'Total tags created' as category,
  COUNT(*) as count
FROM public.tags

UNION ALL

SELECT 
  'Dream-tag relationships' as category,
  COUNT(*) as count
FROM public.dream_tags;
